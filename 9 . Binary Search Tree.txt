#include <iostream>using namespace std;struct Node {    int data;    int countorder;    Node* left;    Node* right;};class BST {public:    Node* root;    int nodecount = 1;    BST() {        root = NULL;    }    Node* addBST(Node* current, int data) {        if(root == NULL)            cout<<"Root was created"<<endl;        if (current == NULL) {            Node* newNode = new Node;            newNode->data = data;            newNode->countorder = nodecount;            nodecount+= 1;            newNode->left = NULL;            newNode->right = NULL;            return newNode;        }        if (data < current->data)             current->left = addBST(current->left, data);        else if (data > current->data)             current->right = addBST(current->right, data);        return current;    }    Node* searchBST(Node* current, int data) {        if (current == NULL || current->data == data)            return current;        if (data < current->data)             return searchBST(current->left, data);        else            return searchBST(current->right, data);    }    Node* deleteBST(Node* current, int data) {        if (current == NULL)            return current;        if (data < current->data)            current->left = deleteBST(current->left, data);        else if (data > current->data)            current->right = deleteBST(current->right, data);        else {            if (current->left == NULL) {                Node* temp = current->right;                delete current;                return temp;            }            else if (current->right == NULL) {                Node* temp = current->left;                delete current;                return temp;            }            Node* temp = findLargestBST(current->left);            current->data = temp->data;            current->left = deleteBST(current->left, temp->data);        }        return current;    }    Node* findSmallestBST(Node* current) {        while (current->left != NULL)            current = current->left;        return current;    }    Node* findLargestBST(Node* current) {        while (current->right != NULL)            current = current->right;        return current;    }    void Inorder(Node* current) {        if (current == NULL)            return;        Inorder(current->left);        cout << current->data << " ";        Inorder(current->right);    }    void preOrder(Node* current) {        if (current == NULL)            return;        cout << current->data << " ";        preOrder(current->left);        preOrder(current->right);    }    void postOrder(Node* current) {        if (current == NULL)            return;        postOrder(current->left);        postOrder(current->right);        cout << current->data << " ";    }};int main() {    BST myBST;    int choice;    int data;    Node* targetNode;    cout << "Binary Search Tree Menu:" << endl;    cout << "1. Add a node\n2. Search for a node\n3. Delete a node\n4. Print tree (Inorder Traversal)\n5. Print tree (Pre-order Traversal)\n6. Print tree (Post-order Traversal)\n7. Find the largest node\n8. Find the smallest node\n9. Exit"<< endl;    while (true) {                cout << "Enter your choice: ";        cin >> choice;        switch (choice) {        case 1:            cout << "Enter data for the new node: ";            cin >> data;            myBST.root = myBST.addBST(myBST.root, data);            break;        case 2:            cout << "Enter the data to search for: ";            cin >> data;            targetNode = myBST.searchBST(myBST.root, data);            if (targetNode)                cout << "Found node with data " << targetNode->data << endl;            else                cout << "Node with data " << data << " not found." << endl;            break;        case 3:            cout << "Enter the data to delete: ";            cin >> data;            myBST.root = myBST.deleteBST(myBST.root, data);            break;        case 4:            cout << "Inorder Traversal: ";            myBST.Inorder(myBST.root);            cout << endl;            break;        case 5:            cout << "Pre-order Traversal: ";            myBST.preOrder(myBST.root);            cout << endl;            break;        case 6:            cout << "Post-order Traversal: ";            myBST.postOrder(myBST.root);            cout << endl;            break;        case 7:            targetNode = myBST.findLargestBST(myBST.root);            cout << "Largest node has data: " << targetNode->data <<" which was created as :"<<targetNode->countorder<< endl;            break;        case 8:            targetNode = myBST.findSmallestBST(myBST.root);            cout << "Smallest node has data: " << targetNode->data<<" which was created as :"<<targetNode->countorder<< endl;            break;        case 9:            cout << "Exiting program." << endl;            return 0;        default:            cout << "Invalid choice. Please select a valid option." << endl;            break;        }    }    return 0;}